<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Obj_CombatMinigameMaster</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

xOff = 0;
yOff = 0;

// Cursor
xCursor = 0;
yCursor = 0;
CursorSpd = 3.0;
RecoilSpd = 1.3;

// Shot Recoil
ShotRecoilMax = 8.0;
ShotRecoilCurr = 0;
ShotRecoilWinddown = 0.2;
ShotRecoilDir = 0; 

// Bounds
Radius = 90;

// HitDetection
GreatRadius = 15;
GoodRadius = 30;
OkayRadius = 50;

// Target
TargetPulse = 0;

// Timer
TimerMinSize = 32;

// GunTrail
TrailLength = 0;
TrailLengthMax = 3;
TrailAlphaMax = 5;
TrailAlpha = 0;
TrailFadeSpeed = 0.15;
TrailDir = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// Position Offset
var enem = instance_find(Obj_EnemyData, Obj_CombatManager.AttackTarget);
if(enem == noone)
{
    CurrentTime = 0;
}
else{
    if(enem.Hitpoints &lt;= 0)
        CurrentTime = 0;
    
    Scr_ConvertPrepare( Obj_CombatRenderer.CamPosX, Obj_CombatRenderer.CamPosY, Obj_CombatRenderer.CamPosZ, Obj_CombatRenderer.CamPosX + 1, Obj_CombatRenderer.CamPosY, Obj_CombatRenderer.CamPosZ, 0, 0, 1, Obj_RenderPipeline.FOV, Obj_RenderPipeline.ScreenWidth/Obj_RenderPipeline.ScreenHeight);
    Scr_Convert3d(enem.x, enem.y, enem.AimOffset, Obj_CombatRenderer.CamPosX, Obj_CombatRenderer.CamPosY, Obj_CombatRenderer.CamPosZ);
}
yOff = y_2d;
xOff = x_2d;

//TimerCheck
if(CurrentTime &gt; 0){
    // Target
    TargetPulse += 1;
    
    // Cursor Movement
    var newX = Obj_InputManager.InputHorizontalAxis * CursorSpd;
    var newY = Obj_InputManager.InputVerticalAxis * CursorSpd;
    
    // Cursor Recoil
    var rxd = xCursor; if(rxd = 0){rxd = irandom_range(-1,1);}
    var ryd = xCursor; if(ryd = 0){ryd = irandom_range(-1,1);}
    newX += -sign(rxd) * lerp(RecoilSpd, 0, abs(xCursor)/(Radius * 0.75));
    newY += -sign(ryd) * lerp(RecoilSpd, 0, abs(yCursor)/(Radius * 0.75));
    
    // ShotRecoil
    newX += cos(ShotRecoilDir) * ShotRecoilCurr;
    newY += sin(ShotRecoilDir) * ShotRecoilCurr;
    ShotRecoilCurr = lerp(ShotRecoilCurr, 0, ShotRecoilWinddown);
    
    // Cursor Bounds
    if(abs(xCursor - newX) &gt; Radius)
        newX = 0;
    
    if(abs(yCursor - newY) &gt; Radius)
        newY = 0;
    
    xCursor = xCursor - newX;
    yCursor = yCursor - newY;
    
    // Firing
    if(Obj_InputManager.InputSelectAxisDown &gt; 0)
    {
        ShotRecoilCurr = ShotRecoilMax;
        ShotRecoilDir = random(2 * pi);
        
        TrailLength = 0;
        TrailAlpha = TrailAlphaMax;
        TrailDir = ShotRecoilDir;
        
        var Dist = abs(point_distance( 0, 0, xCursor, yCursor));
        
        if(Dist &lt; GreatRadius){
            Obj_AttackUsageData.Power = 1.0;
            TextType = MinigamePopupText.empt_Great;
        }
        else if(Dist &lt; GoodRadius){
            Obj_AttackUsageData.Power = 0.8;
            TextType = MinigamePopupText.empt_Good;
        }
        else if(Dist &lt; OkayRadius){
            Obj_AttackUsageData.Power = 0.5;
            TextType = MinigamePopupText.empt_Okay;
        }
        else{
            Obj_AttackUsageData.Power = 0;
            TextType = MinigamePopupText.empt_Miss;
            CurrentTime = 0;
        }
            
        // Do the attack
        with(Obj_AttackUsageData)
        {
            Target = Obj_CombatManager.AttackTarget;
            User = -1;
            Index = Obj_PlayerData.CurrSelectedAmmo;
            event_user(0); // perform gun skill
        }
        
        // Show Popup Text
        TextOriginX = xOff + xCursor;
        TextOriginY = yOff + yCursor;
        TextDirX = sign(xCursor);
        TextDirY = sign(yCursor);
        TextTimer = TextTimerMax;
        
        // Decrement our AmmoCount
        Obj_PlayerData.AmmoInvArray[Obj_PlayerData.CurrSelectedAmmo] -= 1;
        Obj_CombatUI.NumShotsRemaining -= 1;
        if(Obj_CombatUI.NumShotsRemaining &lt;= 0)
            CurrentTime = 0;
    }

    TrailLength = lerp(TrailLength, TrailLengthMax, TrailFadeSpeed);
    TrailAlpha = clamp(TrailAlpha - TrailFadeSpeed, 0, TrailAlphaMax);
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(bEnableDraw){ 
    event_inherited();

    // RENDER TIMER    
    draw_set_alpha(0.6 * FadeAlpha);
    draw_circle(xOff, yOff, (Radius - TimerMinSize) * (CurrentTime/MaxTime) + TimerMinSize, false);
    draw_set_alpha(FadeAlpha);
    draw_circle(xOff, yOff, (Radius - TimerMinSize) * (CurrentTime/MaxTime) + TimerMinSize, true);
    draw_set_alpha(1.0);
    
    // RENDER TARGET
    var Pulse = sin(TargetPulse/8) *  0.25;
    draw_sprite_ext(GUI_Combat_WeaponTarget_GunTargetBacking, 0, xOff, yOff, 1.0 + Pulse, 1.0 + Pulse, 0.0, c_white, 0.8 * FadeAlpha);
    draw_sprite_ext(GUI_Combat_WeaponTarget_GunTargetForeground, 0, xOff, yOff, 1.0 + Pulse, 1.0 + Pulse, 0.0, c_white, 0.8 * FadeAlpha);
    
    // RENDER TRAIL
    //draw_sprite_ext(GUI_Combat_Minigames_GunTrail, 0, xOff + xCursor, yOff + yCursor, 2.0, TrailLength, lerp(0, 360, TrailDir/(2 * pi)), c_white, TrailAlpha * FadeAlpha);

    // RENDER CURSOR
    draw_sprite_ext(GUI_Combat_WeaponTarget_GunTargetBacking, 0, xOff + xCursor, yOff + yCursor, 1.0, 1.0, 0.0, c_white, FadeAlpha);
    draw_sprite_ext(GUI_Combat_WeaponTarget_GunTargetForeground, 0, xOff + xCursor, yOff + yCursor, 1.0, 1.0, 0.0, c_white, FadeAlpha);

    Scr_DrawMinigamePopupText();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
