<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Obj_UIMenuMaster</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Define UI Enum
enum CombatUIState {
    OPEN_PlayerTurn,
    CommandMenu,
    WeaponTargetMenu,
    ACTION_Weapon,
    AmmoMenu,
    SkillMenu,
    SkillTargetMenu,
    COMBATFINALIZE_Skill,
    ItemMenu,
    TalkTargetMenu,
    TalkConverseMenu,
    FleeMenu,
    CLOSE_EnemyTurn,
    ResultsScreen,
    MENULASTINDEX
};

// Call Super Function
event_inherited();

// Set x and y max to that of the command menu on start.
xMax = 0;
yMax = 4;

State = CombatUIState.OPEN_PlayerTurn;

/* Animation Stuff */

// Overall Animators
for(var i = 0; i &lt; CombatUIState.MENULASTINDEX + 1; i += 1){MenuAnim[i] = 0;}
MenuAnimSpeed = 0.1;

// Header Jiggle
HeaderJiggleTimer = 0;
HeaderJiggleSpeed = 1.5;
HeaderJiggleAmount = 2;
HeaderJiggleTimerMax = 90;

// HeaderOverlayJumping
HeaderOverlayPulseTimer = 0;
HeaderOverlayPulseSpeed = 6;
HeaderOverlayPulseAmount = 0.3;
HeaderOverlayRotation = 0;
HeaderOverlayRotationVariation = 4;

// Command Button Displacement
for(var i = 0; i &lt; 5; i += 1){CommandButtonDisplacement[i] = 0;}
MaxButtonDisplacement = 27;
ButtonDisplacementSpeed = 0.15;

// Arrow Movement &amp; Pulsing
SelectArrowLastPos = yPosition * 40;
SelectArrowNewPos = SelectArrowLastPos;
SelectArrowDisplacement = 0;
SelectArrowSpeed = 0.15;

ArrowPulseTimer = 0;

AmmoAnimationMoveDir = 0;
AmmoAnimationPosition = 0;
AmmoAnimationSpeed = 1/FastScrollIntervalTime/2;
AmmoAnimStoredXPos = 0;

// Speed Lines
ActiveSpeedLineIndex = 0;
SpeedLinesHorizontal = 0;
SpeedLinesVertical = 0;

SpeedLinesOffset = 0;
SpeedLinesSpeed = 8;
SpeedLinesMaxOffset =  512;

// Flee
for(var i = 0; i &lt; 2; i += 1){FleeButtonDisplacement[i] = 0;}
FleeArrowAnim = 1.0;

// Stored Stuff
StoredCommandMenuPositon = 0; // Used when returning to the command menu from the Flee or Guard menu
StoredSkillMenuPosition = 0;
OverrideSkill = -1; // Used for calling a skill the player maynot have in their inventory.
bAlreadyFired = false;
NumShotsRemaining = 6;
if(Obj_PlayerData.AmmoInvArray[Obj_PlayerData.CurrSelectedAmmo] &lt; 6){NumShotsRemaining = Obj_PlayerData.AmmoInvArray[Obj_PlayerData.CurrSelectedAmmo];}
bUsingGun = false;

// OpenCloseVars
MaxWaitTime = 30;
WaitTime = MaxWaitTime;
SlideInAnim = 0;
SlideOutAnim = 0;
SlideSpeed = 0.08;

// Player Stats
ShowPlayerStats = false;

MenuCloseTimer = 30;
GunMenuCloseTimer = 30;
SkillMenuCloseTimer = 40;
SkillAnimDelay = 20;

bCurrentAttackTargetsSelf = false;

// Dialogue Variables
enum NegotiationState {
    ENTRY,
    Intro,
    Question,
    Response,
    Resolution
};

negState = NegotiationState.ENTRY;
QuestionIndex = 0;
DialougeSourceString = "";
DialougeBlitString = "";
ConversationPartner = noone;

LastDiaOpt = 0;
CurrDiaOpt = 0;
DiaAnim = 0;

SelectedOptionIndex = 0;
OptionStrings[0] = "";
OptionStrings[1] = "";
OptionStrings[2] = "";

DialougeFrame = 0;
PassCount = 0;
FailCount = 0;

DialougeOptionsAnim = 0;

bPlayersKnowsSkill = false;

// Results Screen
ResultsScreenTimer = 60;
ResultsScreenTimerMax = 60;
LevelUpAnimTimer = 0;
LevelUpAnimTimerMax = 100;

StatBoostsRemaining = 0;
StatBoostMessageAnim = 0;

// PlayerBust
BustUpX = 100;
BustUpY = 360;
BustUpXTarg = BustUpX;
BustUpYTarg = BustUpY;
BustFrame = 0;
BustFrameRate = 0.25;
BustPlayDir = 0;
BustSprite = Spr_Portrait_Hero_CombatEntry;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Call Super Function
event_inherited();

/*********************************************
// Check if combat is over
*********************************************/
if(instance_number(Obj_EnemyData) &lt;= 0)
    __combat_menu_navigate(CombatUIState.ResultsScreen);
//////////////////////////////////////////////

/*********************************************
// Set Properties
*********************************************/
__combat_menu_set_properties();
//////////////////////////////////////////////

/*********************************************
// Select Action
*********************************************/
__combat_menu_select_action();
//////////////////////////////////////////////


/*********************************************
// Return Action
*********************************************/
__combat_menu_return_action();
//////////////////////////////////////////////

switch(State)
{
    case CombatUIState.CommandMenu:
    {    
        /*********************************************
        // Button Displacement
        *********************************************/
        var i;
        for (i = 0; i &lt; 5; i++)
        {
            if(i == yPosition)
            {
                CommandButtonDisplacement[i] += ButtonDisplacementSpeed;
                
                if(CommandButtonDisplacement[i] &gt;= 1.0)
                    CommandButtonDisplacement[i] = 1.0;
            }else{
                CommandButtonDisplacement[i] -= ButtonDisplacementSpeed;
            
                if(CommandButtonDisplacement[i] &lt;= 0)
                    CommandButtonDisplacement[i] = 0;
            }
        }
        //////////////////////////////////////////////
        
        /*********************************************
        // Arrow Movement
        *********************************************/
        if(yPosition * 40 != SelectArrowNewPos){
            SelectArrowLastPos = SelectArrowNewPos;
            SelectArrowNewPos = yPosition * 40;
            SelectArrowDisplacement = 0;
        }
        SelectArrowDisplacement += SelectArrowSpeed;
        if(SelectArrowDisplacement &gt;= 1.0)
            SelectArrowDisplacement = 1.0;
        //////////////////////////////////////////////
        break;
    }
    case CombatUIState.WeaponTargetMenu:
    {        
        /*********************************************
        // Update Reticule Position
        *********************************************/
        Obj_CombatManager.AttackTarget = xPosition;
        //////////////////////////////////////////////
        break;
    }
    case CombatUIState.ACTION_Weapon:
    {        
        if(!instance_exists(Obj_CombatMinigameMaster))
        {
            State = CombatUIState.MENULASTINDEX;
            Scr_Combat_FocusCamera(-1, 30);
        }
        break;
    }
    case CombatUIState.AmmoMenu:
    {                       
        if(AmmoAnimStoredXPos != xPosition)
        {
            if(xPosition = 0 &amp;&amp; AmmoAnimStoredXPos == xMax)
            {
                AmmoAnimationMoveDir = -1;
            }
            else if(xPosition = xMax &amp;&amp; AmmoAnimStoredXPos == 0)
            {
                AmmoAnimationMoveDir = 1;
            }
            else if(AmmoAnimStoredXPos &lt; xPosition)
            {
                AmmoAnimationMoveDir = -1;
            }
            else if(AmmoAnimStoredXPos &gt; xPosition)
            {
                AmmoAnimationMoveDir = 1;
            }
            
            if(AmmoAnimationMoveDir &gt; 0){AmmoAnimationPosition =  0;}else{AmmoAnimationPosition = 1;}
            AmmoAnimStoredXPos = xPosition;
        }
        AmmoAnimationPosition += AmmoAnimationSpeed * AmmoAnimationMoveDir;        
        if(AmmoAnimationMoveDir &gt; 0 &amp;&amp; AmmoAnimationPosition &gt; 1){
            AmmoAnimationPosition = 1;
        }
        else if(AmmoAnimationMoveDir &lt; 0 &amp;&amp; AmmoAnimationPosition &lt; 0){
            AmmoAnimationPosition = 0;
        }
        break;
    }
    case CombatUIState.SkillMenu:
    {   
        StoredSkillMenuPosition = yPosition;
        // Arrow Movement
        if(yPosition * 20 != SelectArrowNewPos){
            SelectArrowLastPos = SelectArrowNewPos;
            SelectArrowNewPos = yPosition * 20;
            SelectArrowDisplacement = 0;
        }
        SelectArrowDisplacement += SelectArrowSpeed;
        if(SelectArrowDisplacement &gt;= 1.0)
            SelectArrowDisplacement = 1.0;
        break;
    }
    case CombatUIState.SkillTargetMenu:
    {
        var tst = Obj_SkillItemData.SkillData[Obj_PlayerData.SkillArray[StoredSkillMenuPosition], 3];
    
        if(tst == WhoToTarget.wtt_Ally || tst == WhoToTarget.wtt_AllAlly || tst == WhoToTarget.wtt_SelfNone)
        {
            bCurrentAttackTargetsSelf = true;
            Obj_CombatManager.AttackTarget = -1;
            Obj_AttackUsageData.Target = -1;
            Obj_CombatRenderer.TType = TargetType.None;
        }else{
            bCurrentAttackTargetsSelf = false;
            Obj_CombatManager.AttackTarget = xPosition;
            Obj_AttackUsageData.Target = xPosition;
            Obj_CombatRenderer.TType = TargetType.Magic;
        }
        break;
    }
    case CombatUIState.COMBATFINALIZE_Skill:
    {           
        if(!instance_exists(Obj_CombatMinigameMaster))
        { 
            SkillAnimDelay -= 1;
            if(SkillAnimDelay &lt;= 0 &amp;&amp; SkillAnimDelay &gt; -500)
            {
                SkillAnimDelay = -501
                // TODO: Actually do the attack stuff
                with(Obj_AttackUsageData)
                {
                    User = -1;
                    if(Obj_CombatUI.OverrideSkill == -1)
                        Index = Obj_PlayerData.SkillArray[Obj_CombatUI.StoredSkillMenuPosition];
                    else
                        Index = Obj_CombatUI.OverrideSkill;
                    event_user(1); // perform skill skill
                }
            }
            
            SkillMenuCloseTimer -= 1;
            if(SkillMenuCloseTimer &lt;= 0)
                State = CombatUIState.MENULASTINDEX;
        }
            
        break;
    }
    case CombatUIState.TalkTargetMenu:
    {       
        if(yPosition == 0){
            Obj_CombatManager.AttackTarget = xPosition;
            Obj_CombatRenderer.TType = TargetType.Talk;
        }else{
            Obj_CombatRenderer.TType = TargetType.None;
        }
        break;
    }
    case CombatUIState.TalkConverseMenu:
    {        
        if(CurrDiaOpt != yPosition)
        {
            LastDiaOpt = CurrDiaOpt;
            CurrDiaOpt = yPosition;
        }
        
        DiaAnim = lerp(DiaAnim, CurrDiaOpt, 0.25);
        
        if(negState = NegotiationState.ENTRY)
        {
            DialougeFrame = 0;
            for(var i = 0; i &lt; array_height_2d(Obj_PlayerData.SkillArray) + 1; i += 1)
            {
                if(Obj_PlayerData.SkillArray[i] == ConversationPartner.TutorSkillIndex)
                {
                    bPlayersKnowsSkill = true;
                    break;
                }        
                else if(Obj_PlayerData.SkillArray[i] == 0)
                {
                    bPlayersKnowsSkill = false;
                }
            }
            
            if(bPlayersKnowsSkill)
                DialougeSourceString = ConversationPartner.AlreadyHasSkillDialogue[irandom_range(0, array_length_1d(ConversationPartner.AlreadyHasSkillDialogue) - 1)];
            else
                DialougeSourceString = ConversationPartner.StartDialougeString[irandom_range(0, array_length_1d(ConversationPartner.StartDialougeString) - 1)];
            negState = NegotiationState.Intro;
        }
        
        if(DialougeFrame &lt; string_length(DialougeSourceString))
        {
            DialougeFrame += 1;
            DialougeBlitString = string_copy(DialougeSourceString, 1, DialougeFrame);
        }
        
        if(DialougeFrame &gt;= string_length(DialougeSourceString) &amp;&amp; negState = NegotiationState.Question)
        {
            DialougeOptionsAnim += MenuAnimSpeed;
            if(DialougeOptionsAnim &gt; 1)
                DialougeOptionsAnim = 1;
        }
        else
        {
            DialougeOptionsAnim -= MenuAnimSpeed;
            if(DialougeOptionsAnim &lt; 0)
                DialougeOptionsAnim = 0;
        }
        break;
    }
    case CombatUIState.FleeMenu:
    {                
        for(var i = 0; i &lt; 2; i += 1)
        {
            if(i == xPosition)
            {
                FleeButtonDisplacement[i] += ButtonDisplacementSpeed;
                if(FleeButtonDisplacement[i] &gt; 1.0){FleeButtonDisplacement[i] = 1.0};
            }
            else
            {
                FleeButtonDisplacement[i] -= ButtonDisplacementSpeed;
                if(FleeButtonDisplacement[i] &lt; 0.0){FleeButtonDisplacement[i] = 0.0};
            }
        }
        
        if(xPosition == 0)
        {
            FleeArrowAnim -= SelectArrowSpeed;
            if(FleeArrowAnim &lt; 0){FleeArrowAnim = 0};
        }    
        else
        {
            FleeArrowAnim += SelectArrowSpeed;
            if(FleeArrowAnim &gt; 1){FleeArrowAnim = 1};
        }      
        break;
    }
    case CombatUIState.OPEN_PlayerTurn:
    {    
        ShowPlayerStats = false;
        
        if(SlideInAnim &lt; 1.0)
        {
            SlideInAnim += SlideSpeed;
        }else{
            SlideInAnim = 1.0;
            if(WaitTime &gt; 0)
                WaitTime -= 1;
            else{
                if(SlideOutAnim &lt; 1.0)
                {
                    SlideOutAnim += SlideSpeed;
                }
                else
                {
                    WaitTime = MaxWaitTime;
                    SlideInAnim = 0;
                    SlideOutAnim = 0;
                    if(Obj_PlayerData.ChargeTurnsRemaining &gt; 0)
                    {
                        xMax = 100;
                        xPosition = Obj_PlayerData.StoredTarget;
                        
                        var tst = Obj_SkillItemData.SkillData[Obj_PlayerData.LastAttackIndex, 3];
                        if(tst == WhoToTarget.wtt_Ally || tst == WhoToTarget.wtt_AllAlly || tst == WhoToTarget.wtt_SelfNone)
                            bCurrentAttackTargetsSelf = true;
                        else
                            bCurrentAttackTargetsSelf = false;
                        
                        State = CombatUIState.COMBATFINALIZE_Skill;
                        OverrideSkill = Obj_PlayerData.LastAttackIndex;
                    }
                    else
                    {
                        ActiveSpeedLineIndex = 1;
                        State = CombatUIState.CommandMenu;
                    }
                }
            }

        }
        break;
    }
    case CombatUIState.CLOSE_EnemyTurn:
    {
        ShowPlayerStats = false;
        
        if(SlideInAnim &lt; 1.0)
        {
            SlideInAnim += SlideSpeed;
        }else{
            SlideInAnim = 1.0;
            if(WaitTime &gt; 0)
                WaitTime -= 1;
            else{
                if(SlideOutAnim &lt; 1.0)
                {
                    SlideOutAnim += SlideSpeed;
                }
                else
                {
                    ShowPlayerStats = true;
                    Obj_CombatManager.State = CombatState.ActionState;
                    instance_destroy();
                }
            }
        }
        break;
    }
    case CombatUIState.MENULASTINDEX:
    {
        ShowPlayerStats = false;
        
        ActiveSpeedLineIndex = 0;
        MenuCloseTimer -= 1;
        Obj_CombatRenderer.TType = TargetType.None;
        if(MenuCloseTimer &lt;= 0)
        {
            if(instance_number(Obj_EnemyData) == 0)
                State = CombatUIState.ResultsScreen;
            else
                State = CombatUIState.CLOSE_EnemyTurn;
        }
        break;
    }    
    case CombatUIState.ResultsScreen:
    {
        yMax = 3;
        
        if(ResultsScreenTimer &gt; 0)
            ResultsScreenTimer -= 1;
        else{
            if(Obj_CombatManager.XPGainedDuringBattle &gt; 0)
            {
                Obj_CombatManager.XPGainedDuringBattle -= 1;
                if(Obj_CombatManager.XPGainedDuringBattle &lt;= 0)
                    ResultsScreenTimer = ResultsScreenTimerMax;
                    
                Obj_PlayerData.Experience += 1;
                if(Scr_CheckForLevelUp())
                {
                    LevelUpAnimTimer = LevelUpAnimTimerMax;
                    StatBoostsRemaining += 1;
                }
            }
            else if(Obj_CombatManager.GoldGainedDuringBattle &gt; 0)
            {
                Obj_CombatManager.GoldGainedDuringBattle -= 1;
                if(Obj_CombatManager.GoldGainedDuringBattle &lt;= 0)
                    ResultsScreenTimer = ResultsScreenTimerMax;
                    
                Obj_PlayerData.Gold += 1;
            }
            else if(StatBoostsRemaining &gt; 0)
            {
                StatBoostMessageAnim += MenuAnimSpeed;
                if(StatBoostMessageAnim &gt; 1.0)
                    StatBoostMessageAnim = 1;
            }else{
                StatBoostMessageAnim -= MenuAnimSpeed;
            }
        }
        // Skipped Stuff &amp; Stat Up Inputs
        if(Obj_InputManager.InputSelectAxisDown &gt; 0){
            if(ResultsScreenTimer &gt; 0)
                ResultsScreenTimer = 0;
            else{
                if(Obj_CombatManager.XPGainedDuringBattle &gt; 0)
                {                        
                    Obj_PlayerData.Experience += Obj_CombatManager.XPGainedDuringBattle;
                    Obj_CombatManager.XPGainedDuringBattle = 0;
                    while(Scr_CheckForLevelUp())
                    {
                        LevelUpAnimTimer = LevelUpAnimTimerMax;
                        StatBoostsRemaining += 1;
                    }
                    ResultsScreenTimer = ResultsScreenTimerMax;
                }
                else if(Obj_CombatManager.GoldGainedDuringBattle &gt; 0)
                {
                    Obj_PlayerData.Gold += Obj_CombatManager.GoldGainedDuringBattle;
                    Obj_CombatManager.GoldGainedDuringBattle = 0;
                    ResultsScreenTimer = ResultsScreenTimerMax;
                }
                // Picking Stats Here
                else if(StatBoostsRemaining &gt; 0)
                {
                    switch(yPosition){
                        case 0: Obj_PlayerData.Strength += 1; break;
                        case 1: Obj_PlayerData.Endurance += 1; break;
                        case 2: Obj_PlayerData.Agility += 1; break;
                        case 3: Obj_PlayerData.Luck += 1; break;
                    }
                    StatBoostsRemaining -= 1;
                }
                else
                {
                    // LEAVE COMBAT HERE
                    Obj_CombatManager.State = CombatState.EndState;
                }
            }
        }
        
        LevelUpAnimTimer -= 1;
        break;
    }
}

// Animation Stuff //
for(var i = 0; i &lt; CombatUIState.MENULASTINDEX + 1; i += 1)
{
    if(i == State)
    {
        MenuAnim[i] += MenuAnimSpeed;
        if(MenuAnim[i] &gt; 1.0)
            MenuAnim[i] = 1.0;
    }
    else
    {
        MenuAnim[i] -= MenuAnimSpeed;
        if(MenuAnim[i] &lt; 0.0)
            MenuAnim[i] = 0.0;
    }
}

// Player Stats
var ui = instance_find(Obj_PlayerStatsHUD, 0);
if(ui != noone){
    ui.ShowPlayerStats = ShowPlayerStats;
}

if(ActiveSpeedLineIndex = 0)
{
    SpeedLinesHorizontal -= MenuAnimSpeed;
    if(SpeedLinesHorizontal &lt; 0.0)
        SpeedLinesHorizontal = 0.0;
    SpeedLinesVertical -= MenuAnimSpeed;
    if(SpeedLinesVertical &lt; 0.0)
        SpeedLinesVertical = 0.0;
}
else if(ActiveSpeedLineIndex = 1)
{
    SpeedLinesHorizontal -= MenuAnimSpeed;
    if(SpeedLinesHorizontal &lt; 0.0)
        SpeedLinesHorizontal = 0.0;
    SpeedLinesVertical += MenuAnimSpeed;
    if(SpeedLinesVertical &gt; 1.0)
        SpeedLinesVertical = 1.0;
}
else if(ActiveSpeedLineIndex = 2)
{
    SpeedLinesHorizontal += MenuAnimSpeed;
    if(SpeedLinesHorizontal &gt; 1.0)
        SpeedLinesHorizontal = 1.0;
    SpeedLinesVertical -= MenuAnimSpeed;
    if(SpeedLinesVertical &lt; 0.0)
        SpeedLinesVertical = 0.0;
}

HeaderJiggleTimer += 1;
if(HeaderJiggleTimer &gt;= HeaderJiggleTimerMax)
    HeaderJiggleTimer = 0;
    
HeaderOverlayPulseTimer += 1;

ArrowPulseTimer += 1;

SpeedLinesOffset += SpeedLinesSpeed;
if(SpeedLinesOffset &gt; SpeedLinesMaxOffset){
    SpeedLinesOffset -= SpeedLinesMaxOffset;
}

// PlayerBust
BustUpX = lerp(BustUpX, BustUpXTarg, 0.15);
BustUpY = lerp(BustUpY, BustUpYTarg, 0.15);
BustFrame = clamp(BustFrame + (BustFrameRate*BustPlayDir), 0, sprite_get_number(BustSprite)-1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sound_play(Snd_Debug_MenuHover);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> if(bEnableDraw){    

    // Animation Stuff
    // Header Jiggle
    var r = sin(HeaderJiggleTimer / HeaderJiggleSpeed) * HeaderJiggleAmount;
    if(HeaderJiggleTimer / HeaderJiggleSpeed &gt; 4*pi)
        r = 0;
        
    var j = sin(HeaderOverlayPulseTimer/HeaderOverlayPulseSpeed) * HeaderOverlayPulseAmount;
    if(HeaderOverlayPulseTimer/HeaderOverlayPulseSpeed &gt; pi){
        HeaderOverlayPulseTimer = 0;
        HeaderOverlayRotation = random_range( -10, 10);
    }
        
    var i;
    var str;
    
    var SLH = 1 - (Scr_SCurve(SpeedLinesHorizontal));
    var SLV = 1 - (Scr_SCurve(SpeedLinesVertical));
    
    // SpeedLines Vertical
    if(SpeedLinesVertical &gt; 0)
    {
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Backing, -1, 448 + (192 * SLV), 0 - SpeedLinesOffset, 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Backing, -1, 448 + (192 * SLV), 512 - SpeedLinesOffset, 1.0, 1.0, 0.0, c_white, 1.0);
        
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines, -1, 448 + (192 * SLV), -512 + SpeedLinesOffset, 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines, -1, 448 + (192 * SLV), 0 + SpeedLinesOffset, 1.0, 1.0, 0.0, c_white, 1.0);
    }
    
    // Speedlines Horizontal
    if(SpeedLinesHorizontal &gt; 0)
    {
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing, -1, 0 - SpeedLinesOffset, 0 - (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing, -1, 512 - SpeedLinesOffset, 0 - (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing, -1, 1024 - SpeedLinesOffset, 0 - (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal, -1, -512 + SpeedLinesOffset, 0 - (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal, -1, 0 + SpeedLinesOffset, 0 - (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal, -1, 512 + SpeedLinesOffset, 0 - (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing, -1, -512 + SpeedLinesOffset, 312 + (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing, -1, 0 + SpeedLinesOffset, 312 + (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing, -1, 512 + SpeedLinesOffset, 312 + (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal, -1, 0 - SpeedLinesOffset, 312 + (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal, -1, 512 - SpeedLinesOffset, 312 + (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal, -1, 1024 - SpeedLinesOffset, 312 + (48 * SLH), 1.0, 1.0, 0.0, c_white, 1.0);
    }
    
    /***************************************************************************
    // PLAYER BUST
    ***************************************************************************/ 
    //draw_sprite_ext(BustSprite, BustFrame, BustUpX, BustUpY, 1.0,1.0,0.0,c_white,1.0);
    
    /***************************************************************************
    // CombatUIState.CommandMenu
    ***************************************************************************/
    if(MenuAnim[CombatUIState.CommandMenu] &gt; 0){
        var CommandAnimOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.CommandMenu])) * 260;
        var CommandAnimHeaderOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.CommandMenu])) * 90;
        
        // HEADER
        draw_sprite_ext( GUI_Combat_Command_Header, -1, 512, 39 - CommandAnimHeaderOffset, 1.0, 1.0, r, c_white, 1.0);
        
        // MENU OPTIONS
        for(i = 0; i &lt;= yMax; i += 1)
        {
            switch(i)
            {
                // WEAPON OPTION
                case 0:
                {
                    draw_sprite_ext( GUI_Combat_Command_WeaponBtn, -1, 610 - (MaxButtonDisplacement * Scr_SCurve(CommandButtonDisplacement[i])) + CommandAnimOffset, 76 + (i * 40), 1.0, 1.0, 0.0, c_white, 1.0);
                    break;
                }
                // SKILL OPTION
                case 1:
                {
                    draw_sprite_ext( GUI_Combat_Command_SkillBtn, -1, 610 - (MaxButtonDisplacement * Scr_SCurve(CommandButtonDisplacement[i])) + CommandAnimOffset, 76 + (i * 40), 1.0, 1.0, 0.0, c_white, 1.0);
                    break;
                }
                // ITEMS OPTION
                case 2:
                {
                    draw_sprite_ext( GUI_Combat_Command_ItemsBtn, -1, 610 - (MaxButtonDisplacement * Scr_SCurve(CommandButtonDisplacement[i])) + CommandAnimOffset, 76 + (i * 40), 1.0, 1.0, 0.0, c_dkgray, 1.0);
                    break;
                }
                // TALK OPTION
                case 3:
                {
                    draw_sprite_ext( GUI_Combat_Command_TalkBtn, -1, 610 - (MaxButtonDisplacement * Scr_SCurve(CommandButtonDisplacement[i])) + CommandAnimOffset, 76 + (i * 40), 1.0, 1.0, 0.0, c_white, 1.0);
                    break;
                }
                // FLEE OPTION
                case 4:
                {
                    draw_sprite_ext( GUI_Combat_Command_FleeBtn, -1, 610 - (MaxButtonDisplacement * Scr_SCurve(CommandButtonDisplacement[i])) + CommandAnimOffset, 76 + (i * 40), 1.0, 1.0, 0.0, c_white, 1.0);
                    break;
                }
            }
        }
        
        // SELECT ARROW
        var s = sin(ArrowPulseTimer / 6);
        draw_sprite_ext( GUI_Combat_Command_Arrow, 0, 598 - (s * 8) + CommandAnimOffset, 91 + lerp(SelectArrowLastPos, SelectArrowNewPos, Scr_SCurve(SelectArrowDisplacement)), lerp(1.4, 1.0, clamp(s, 0.0, 1.0)), lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)), 0.0, c_white, 1.0);
    }
    
    /***************************************************************************
    // CombatUIState.WeaponTargetMenu
    ***************************************************************************/
    if(MenuAnim[CombatUIState.WeaponTargetMenu] &gt; 0)
    {
        var WeaponTargetAnimHeaderOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.WeaponTargetMenu])) * 110;
        var WeaponTargetAnimSwitchOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.WeaponTargetMenu])) * 170;
        var WeaponTargetAnimAmmoOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.WeaponTargetMenu])) * 260;
            
        // HEADER
        draw_sprite_ext( GUI_Combat_WeaponTarget_Header, -1, 534, 40 - WeaponTargetAnimHeaderOffset, 1.0, 1.0, 0, c_white, 1.0);
        
        // FIRE!!
        draw_sprite_ext( GUI_Combat_WeaponTarget_Fire, -1, 531, 61 - WeaponTargetAnimHeaderOffset, 1.0 + j, 1.0 + j, HeaderOverlayRotation, c_white, 1.0);
        
        // CHANGE AMMO
        if(bAlreadyFired){
            draw_sprite_ext( GUI_Combat_WeaponTarget_ChangeAmmo, -1, 563 + WeaponTargetAnimSwitchOffset, 320, 1.0, 1.0, 0.0, c_dkgray, 1.0);
            draw_sprite_ext( GUI_Combat_WeaponTarget_LockedIn, -1, 475 + WeaponTargetAnimSwitchOffset, 290, 1.0, 1.0, 0.0, c_white, 1.0);
        }
        else{            
            draw_sprite_ext( GUI_Combat_WeaponTarget_ChangeAmmo, -1, 563 + WeaponTargetAnimSwitchOffset, 320, 1.0, 1.0, r, c_white, 1.0);
        }
        
        // CHANGE AMMO ARROW
        if(yPosition == 1)
        {
            var s = sin(ArrowPulseTimer / 6);
            draw_sprite_ext( GUI_Combat_Command_Arrow, 1, 454 - (s * 8) + WeaponTargetAnimSwitchOffset, 332, lerp(1.4, 1.0, clamp(s, 0.0, 1.0)), lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)), 0, c_white, 1.0);  
        }
        
        // CURRENT AMMO COUNT
        if(Obj_PlayerData.AmmoInvArray[Obj_PlayerData.CurrSelectedAmmo] &gt; 0){
            draw_sprite_ext( GUI_Combat_Ammo_AmmoIcon, Obj_PlayerData.CurrSelectedAmmo, 64 - WeaponTargetAnimAmmoOffset, 296, 1.0, 1.0, 1.0, c_white, 1.0);
            Scr_DrawText( "x" + string(Obj_PlayerData.AmmoInvArray[Obj_PlayerData.CurrSelectedAmmo] - NumShotsRemaining), 108 - WeaponTargetAnimAmmoOffset, 290, 0.6, GUI_Font_OldStyleKana_Lrg);
        }
        else{
            draw_sprite_ext( GUI_Combat_Ammo_AmmoIcon, Obj_PlayerData.CurrSelectedAmmo, 64 - WeaponTargetAnimAmmoOffset, 296, 1.0, 1.0, 1.0, c_dkgray, 1.0);
            draw_sprite_ext( GUI_Combat_Ammo_AmmoEmpty, -1, 64 - WeaponTargetAnimAmmoOffset, 296, 1.0, 1.0, 1.0, c_white, 1.0);
        }
    }
    
    /***************************************************************************
    // CombatUIState.AmmoMenu
    ***************************************************************************/
    if(MenuAnim[CombatUIState.AmmoMenu] &gt; 0)
    {
        var AmmoAnimHeaderOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.AmmoMenu])) * 110;
        var AmmoAnimFireOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.AmmoMenu])) * 150;
        var AmmoAnimInfoOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.AmmoMenu])) * 460;
        var AmmoAnimSelectScale = Scr_SCurve(MenuAnim[CombatUIState.AmmoMenu]);
        
        rFact = yPosition; 
            
        // BACKER
        draw_sprite_ext( GUI_Combat_Ammo_Backing, -1,  320, 180, 1.0, AmmoAnimSelectScale, 0.0, c_white, 1.0);
        
        // HEADER
        draw_sprite_ext( GUI_Combat_Ammo_Header, -1,  535, 58 - AmmoAnimHeaderOffset, 1.0, 1.0, r * (1 - rFact), c_white, 1.0);
        
        // FIRE
        draw_sprite_ext( GUI_Combat_Ammo_Fire, -1, 569 + AmmoAnimFireOffset, 318, 1.0, 1.0, r * (0 + rFact), c_white, 1.0);
        
        // DRAW THE AMMO TYPE ICONS
        var i;
        for(i = (xPosition - 3); i &lt;= (xPosition + 3); i += 1)
        {              
            var iOff = i;
            var tmpXMax = array_height_2d(Obj_SkillItemData.AmmoData) - 1;
            // Constrain J so that we don't try to draw nonexistent shit
            if(iOff &lt; 0){iOff += array_length_1d(Obj_PlayerData.AmmoInvArray)}
            else if(iOff &gt; tmpXMax){iOff -= array_length_1d(Obj_PlayerData.AmmoInvArray)}
            
            var s = 1.0;                
            var xO = 0;

            // FUCKKKKKKKK
            if(AmmoAnimationMoveDir &gt; 0){
                //A-LowerDummy
                if(i == (xPosition - 3)){s = 0.6; xO = lerp(-80, -80, AmmoAnimationPosition);}
                //B
                else if(i == (xPosition - 2)){s = 0.6; xO = lerp(-80, 40, AmmoAnimationPosition);}
                //C
                else if(i == (xPosition - 1)){s = lerp(0.6, 0.8, AmmoAnimationPosition); xO = lerp(40, 160, AmmoAnimationPosition);}
                //D-Main
                else if(i == xPosition){s = lerp(0.8, 1.0, AmmoAnimationPosition); xO = lerp(160, 320, AmmoAnimationPosition);}
                //E
                else if(i == (xPosition + 1)){s = lerp(1.0, 0.8, AmmoAnimationPosition); xO = lerp(320, 480, AmmoAnimationPosition);}
                //F
                else if(i == (xPosition + 2)){s = lerp(0.8, 0.6, AmmoAnimationPosition); xO = lerp(480, 600, AmmoAnimationPosition);}
                //G-UpperDummy
                else if(i == (xPosition + 3)){s = 0.6; xO = lerp(600, 720, AmmoAnimationPosition);}
            }else if(AmmoAnimationMoveDir &lt;= 0)
            {
                //A-LowerDummy
                if(i == (xPosition - 3)){s = 0.6; xO = lerp(-80, 40, AmmoAnimationPosition);}
                //B
                else if(i == (xPosition - 2)){s = lerp(0.6, 0.8, AmmoAnimationPosition); xO = lerp(40, 160, AmmoAnimationPosition);}
                //C
                else if(i == (xPosition - 1)){s = lerp(0.8, 1.0, AmmoAnimationPosition); xO = lerp(160, 320, AmmoAnimationPosition);}
                //D-Main
                else if(i == xPosition){s = lerp(1.0, 0.8, AmmoAnimationPosition); xO = lerp(320, 480, AmmoAnimationPosition);}
                //E
                else if(i == (xPosition + 1)){s = lerp(0.8, 0.6, AmmoAnimationPosition); xO = lerp(480, 600, AmmoAnimationPosition);}
                //F
                else if(i == (xPosition + 2)){s = 0.6; xO = lerp(600, 720, AmmoAnimationPosition);}
                //G-UpperDummy
                else if(i == (xPosition + 3)){s = 0.6; xO = lerp(720, 720, AmmoAnimationPosition);}
            }
            
            // Draw the sprite (TODO: CURRENTLY JUST DRAWS SOME LOOPY DUMMY SPRITE)
            var scale = 0;
            if(i == xPosition &amp;&amp; yPosition == 0)
                scale = j/2;
                
            var finalScale = (s + scale) * AmmoAnimSelectScale;
            
            if(Obj_PlayerData.AmmoInvArray[iOff] == 0)
            {
                draw_sprite_ext( GUI_Combat_Ammo_AmmoIcon, iOff, xO, 187, finalScale, finalScale, 1.0, c_dkgray, 1.0);
                draw_sprite_ext( GUI_Combat_Ammo_AmmoEmpty, iOff, xO, 187, finalScale, finalScale, 1.0, c_white, 1.0);
            }
            else
            {
                draw_sprite_ext( GUI_Combat_Ammo_AmmoIcon, iOff, xO, 187, finalScale, finalScale, 1.0, c_white, 1.0);
                if((iOff == Obj_PlayerData.CurrSelectedAmmo))
                    draw_sprite_ext( GUI_Combat_Ammo_AmmoCurrent, iOff, xO, 187, finalScale, finalScale, 1.0, c_white, 1.0);
            }
        }
        
        // AMMO TYPE NAME
        var ammoname;
        
        draw_sprite_ext( GUI_Combat_Ammo_AmmoName, -1, 0 - AmmoAnimInfoOffset, 272, 1, 1, 0, c_white, 1.0);            
        Scr_DrawText("#c031027027" + Obj_SkillItemData.AmmoData[xPosition, 0], 20 - AmmoAnimInfoOffset, 283, 0.8, GUI_Font_OldStyleKana);
        
        // AMMO TYPE DESC
        draw_sprite_ext( GUI_Combat_Ammo_AmmoDesc, -1, 0 - AmmoAnimInfoOffset, 316, 1, 1, 0, c_white, 1.0);
        Scr_DrawText("#c031027027" + Obj_SkillItemData.AmmoData[xPosition, 1], 20 - AmmoAnimInfoOffset, 328, 0.8, GUI_Font_OldStyleKana);
        
        // FIRE ARROW
        if(yPosition == 1)
        {
            var s = sin(ArrowPulseTimer / 6);
            draw_sprite_ext( GUI_Combat_Command_Arrow, 1, 454 - (s * 8) + AmmoAnimFireOffset, 332, lerp(1.4, 1.0, clamp(s, 0.0, 1.0)), lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)), 0, c_white, 1.0);  
        }
    }
    
    /***************************************************************************
    // CombatUIState.SkillMenu
    ***************************************************************************/
    if(MenuAnim[CombatUIState.SkillMenu] &gt; 0)
    {
        var SkillAnimHeaderOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.SkillMenu])) * 70;
        var SkillAnimListOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.SkillMenu])) * 300;
    
        // HEADER
        draw_sprite_ext( GUI_Combat_SkillSelect_Header, -1, 512, 39 - SkillAnimHeaderOffset, 1.0, 1.0, r, c_white, 1.0);
        
        // LIST
        for(var i = -1; i &lt; 9; i += 1)
        {
            var sName = "   ";
            var bPlayerCanAfford = true;
            var Cost = 0;
                
            var CostColourString = "#c050050050";
            
            if(i &gt;= 0  &amp;&amp; i &lt;= 7)
            {
                Cost = Obj_SkillItemData.SkillData[Obj_PlayerData.SkillArray[i], 2];
                
                if(Cost &gt; 0 &amp;&amp; Cost &gt; Obj_PlayerData.Manapoints)
                    bPlayerCanAfford = false;
                else if(Cost &lt; 0 &amp;&amp; abs(Cost) &gt;= Obj_PlayerData.Hitpoints)
                    bPlayerCanAfford = false;
                
                if(Obj_PlayerData.SkillArray[i] != 0)
                {
                    var WhiteSpace = 16;
                    sName = Obj_SkillItemData.SkillData[Obj_PlayerData.SkillArray[i], 0];
                    if(Cost != 0){
                        var WhiteSpace = 20;
                        WhiteSpace -= string_length(sName);
                        WhiteSpace -= string_length(string(abs(Cost)));
                            
                        while(WhiteSpace &gt; 0)
                        {
                            sName = sName + " ";
                            WhiteSpace -= 1;
                        }                    
                                                    
                        if(bPlayerCanAfford){
                            CostColourString = "#c015015179";
                            if(Cost &lt; 0)
                                CostColourString = "#c179015015";
                        }
                
                        sName = sName + CostColourString + string(abs(Cost));
                    }
                }
                else
                {
                    bPlayerCanAfford = false;
                }
            }
            
            if(i == -1)
                draw_sprite_ext( GUI_Combat_SkillSelect_SkillListTopper, -1, 346 + SkillAnimListOffset, 80 + (20 * (i + 1)) - 1, 1.0, 1.0, 0.0, c_white, 1.0);                    
            else if(i == 8)
                draw_sprite_ext( GUI_Combat_SkillSelect_SkillListBottom, -1, 346 + SkillAnimListOffset, 80 + (20 * (i + 1)), 1.0, 1.0, 0.0, c_white, 1.0);
            else{
                if(yPosition == i){
                    draw_sprite_ext( GUI_Combat_SkillSelect_SkillListEntry_Highlighted, -1, 346 + SkillAnimListOffset, 80 + (20 * (i + 1)), 1.0, 1.0, 0.0, c_white, 1.0);  
                    Scr_DrawText("#c031027027" + sName, 358 + SkillAnimListOffset, 80 + (20 * (i + 1)), 0.8, GUI_Font_OldStyleKana);
                }else{
                    var HighlightCol = c_white;
                    if(!bPlayerCanAfford)
                    {
                        HighlightCol = c_dkgray;
                        sName = CostColourString + sName;
                    }
                    draw_sprite_ext( GUI_Combat_SkillSelect_SkillListEntry, -1, 346 + SkillAnimListOffset, 80 + (20 * (i + 1)), 1.0, 1.0, 0.0, c_white, 1.0);
                    Scr_DrawText(sName, 358 + SkillAnimListOffset, 80 + (20 * (i + 1)), 0.8, GUI_Font_OldStyleKana);
                }  
            }
        }
        
        if(Obj_PlayerData.SkillArray[0] == 0)
        {
            var losp = 1.0 + sin(ArrowPulseTimer / 10) * 0.05;
            draw_sprite_ext( GUI_Combat_SkillSelect_LackOfSkills, -1, 478 + SkillAnimListOffset, 178, losp, losp, 0, c_white, 1.0);
        }
        
        // SELECT ARROW
        var s = sin(ArrowPulseTimer / 6);
        draw_sprite_ext( GUI_Combat_SkillSelect_SkillListSelectArrow, -1, 614 - (s * 8), 109 + lerp(SelectArrowLastPos, SelectArrowNewPos, Scr_SCurve(SelectArrowDisplacement)), lerp(1.4, 1.0, clamp(s, 0.0, 1.0)), lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)), 0.0, c_white, 1.0);
        
    }
    
    ///////////////////////////////////
    // Skill Info Section
    ///////////////////////////////////
    if(MenuAnim[CombatUIState.SkillMenu] &gt; 0 || MenuAnim[CombatUIState.SkillTargetMenu] &gt; 0)
    {
        var SkillAnimInfoOffset = Scr_SCurve(1 -(MenuAnim[CombatUIState.SkillTargetMenu] + MenuAnim[CombatUIState.SkillMenu])) * 460;
        
        // SKILL DESC
        draw_sprite_ext( GUI_Combat_SkillSelect_SkillDesc, -1, 183 + SkillAnimInfoOffset, 284, 1, 1, 0, c_white, 1.0);
        if(Obj_PlayerData.SkillArray[yPosition] != 0)
            Scr_DrawText("#c031027027" + Obj_SkillItemData.SkillData[Obj_PlayerData.SkillArray[StoredSkillMenuPosition], 1], 202 + SkillAnimInfoOffset, 295, 0.8, GUI_Font_OldStyleKana);  
    }
    
    /***************************************************************************
    // CombatUIState.SkillTargetMenu
    ***************************************************************************/
    if(MenuAnim[CombatUIState.SkillTargetMenu] &gt; 0)
    {
        var SkillAnimNameOffset = (1 -Scr_SCurve(MenuAnim[CombatUIState.SkillTargetMenu])) * 460;
        var SkillTargetAnimHeaderOffset = (1 -Scr_SCurve(MenuAnim[CombatUIState.SkillTargetMenu])) * 110;
    
        // HEADER
        draw_sprite_ext( GUI_Combat_SkillSelect_Header, -1, 512, 39 - SkillTargetAnimHeaderOffset, 1.0, 1.0, 0, c_white, 1.0);
        
        // CAST!!
        draw_sprite_ext( GUI_Combat_SkillTarget_Cast, -1, 523, 63 - SkillTargetAnimHeaderOffset, 1.0 + j, 1.0 + j, HeaderOverlayRotation, c_white, 1.0);
        
        // SKILL NAME
        draw_sprite_ext( GUI_Combat_SkillSelect_SkillDesc, -1, 456 + SkillAnimNameOffset, 240, 1, 1, 0, c_white, 1.0);
        Scr_DrawText("#c031027027" + Obj_SkillItemData.SkillData[Obj_PlayerData.SkillArray[StoredSkillMenuPosition], 0], 475 + SkillAnimNameOffset, 251, 0.8, GUI_Font_OldStyleKana);
   
        
        //var s = sin(ArrowPulseTimer / 6);
        //draw_sprite_ext( GUI_Combat_Command_Arrow, 0, 598 - (s * 8) + CommandAnimOffset, 91 + lerp(SelectArrowLastPos, SelectArrowNewPos, Scr_SCurve(SelectArrowDisplacement)), lerp(1.4, 1.0, clamp(s, 0.0, 1.0)), lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)), 0.0, c_white, 1.0);
        
        // SELF SELECT
        if(bCurrentAttackTargetsSelf)
        {
            var s = sin(ArrowPulseTimer / 6);
            // FlameBack 
            draw_sprite_ext( GUI_Combat_SkillTarget_SkillTargetBacking, Obj_CombatRenderer.ReticuleFrame, 40 - SkillAnimNameOffset, 280 + (s * 20) - 40, lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)) * 0.75, lerp(1.4, 1.0, clamp(s, 0.0, 1.0)) * 0.75, 0, c_white, 1.0);
            // Arrow
            draw_sprite_ext( GUI_Combat_SkillTarget_SelfTargetArrow, -1, 40 - SkillAnimNameOffset, 280 + (s * 8), lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)), lerp(1.4, 1.0, clamp(s, 0.0, 1.0)), 0, c_white, 1.0);
            // FlameTop
            draw_sprite_ext( GUI_Combat_SkillTarget_SkillTargetForeground, Obj_CombatRenderer.ReticuleFrame, 40 - SkillAnimNameOffset, 280 + (s * 20) - 40, lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)) * 0.75, lerp(1.4, 1.0, clamp(s, 0.0, 1.0)) * 0.75, 0, c_white, 1.0);
        }
    }
    
    ///////////////////////////////////
    // Talk Header Section
    ///////////////////////////////////
    if(MenuAnim[CombatUIState.TalkTargetMenu] &gt; 0 || MenuAnim[CombatUIState.TalkConverseMenu] &gt; 0)
    {
        var TalkTargetAnimHeaderOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.TalkTargetMenu] + MenuAnim[CombatUIState.TalkConverseMenu])) * 80;
        var TalkTargetBGOffset = (1 - Scr_SCurve(MenuAnim[CombatUIState.TalkTargetMenu] + MenuAnim[CombatUIState.TalkConverseMenu])) * (128 + 8);
        
        // BG
        for(var i = 0; i &lt;= 21; i += 1)
        {  
            var a = global.Time % 32;
            //Top
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 1, -32 + (32 * i) + a, - TalkTargetBGOffset, 1.0, 1.0, 0, c_black, 0.25);
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 1, -32 + (32 * i) + a, -32 - TalkTargetBGOffset, 1.0, 1.0, 0, c_black, 0.5);
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 1, -32 + (32 * i) + a, -64 - TalkTargetBGOffset, 1.0, 1.0, 0, c_black, 0.75);
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 1, -32 + (32 * i) + a, -96 - TalkTargetBGOffset, 1.0, 1.0, 0, c_white, 1.0);
            //Bottom
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 0, 640 - (32 * i) - a, 328 - 96 + TalkTargetBGOffset, 1.0, 1.0, 0, c_black, 0.25);            
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 0, 640 - (32 * i) - a, 328 - 64 + TalkTargetBGOffset, 1.0, 1.0, 0, c_black, 0.5);
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 0, 640 - (32 * i) - a, 328 - 32 + TalkTargetBGOffset, 1.0, 1.0, 0, c_black, 0.75);                                    
            draw_sprite_ext(GUI_Combat_TalkConverse_BGPart, 0, 640 - (32 * i) - a, 328 + TalkTargetBGOffset, 1.0, 1.0, 0, c_white, 1.0);
        }
        
        // HEADER
        draw_sprite_ext( GUI_Combat_TalkTarget_Header, -1, 567, 43 - TalkTargetAnimHeaderOffset, 1.0, 1.0, 0, c_white, 1.0);
    }
    
    /***************************************************************************
    // CombatUIState.TalkConverseMenu
    ***************************************************************************/
    if(MenuAnim[CombatUIState.TalkConverseMenu] &gt; 0)
    {
        var DialougeAnimNameOffset = (1 -Scr_SCurve(MenuAnim[CombatUIState.TalkConverseMenu])) * 100;
        var PulseA = sin(global.Time/8) * 0.025 + 0.3;
        var PulseB = cos(global.Time/8) * 0.025 + 0.2;
        
        // Text Box
        if(ConversationPartner!= noone){
            var e = ConversationPartner;
            Scr_ConvertPrepare( Obj_CombatRenderer.CamPosX, Obj_CombatRenderer.CamPosY, Obj_CombatRenderer.CamPosZ, Obj_CombatRenderer.CamPosX + 1, Obj_CombatRenderer.CamPosY, Obj_CombatRenderer.CamPosZ, 0, 0, 1, Obj_RenderPipeline.FOV, Obj_RenderPipeline.ScreenWidth/Obj_RenderPipeline.ScreenHeight);
            Scr_Convert3d(e.x, e.y + e.DrawSize, e.AimOffset, Obj_CombatRenderer.CamPosX, Obj_CombatRenderer.CamPosY, Obj_CombatRenderer.CamPosZ);
        
            draw_sprite_ext( GUI_Combat_TalkConverse_SpeechBubble, -1, x_2d, y_2d, 1.0 + PulseA, 1.0 + PulseB, 0, c_white, MenuAnim[CombatUIState.TalkConverseMenu]);
            __draw_text(x_2d - 12, y_2d - 42, "#a" + string(MenuAnim[CombatUIState.TalkConverseMenu] * 255) + "#c031027027" + DialougeBlitString, Spr_Font_MilleniumFont, 0.4, 0.5);
        }
        
        // DialogueOptions
        if(DialougeOptionsAnim){
            for(var i = 0; i &lt; 3; i += 1)
            {
                var Off = (DiaAnim - i)
                var PulseA = sin((global.Time - (i * 32.6))/8) * 0.025;
                var PulseB = cos((global.Time - (i * 32.6))/8) * 0.025;
                var col = c_gray;
                if(i == yPosition)
                {
                    PulseA += 0.1;
                    PulseB += 0.1;
                    col = c_white;
                }
                draw_sprite_ext( GUI_Combat_TalkConverse_OptionBubble, -1, round(160 - (abs(Off) * 32)), round(168 + (-Off * 64)), 1.0 + PulseA, 1.0 + PulseB, 0, col, DialougeOptionsAnim);
                __draw_text(round(160 - (abs(Off) * 32)), round(156 + (-Off * 64)), "#a" + string(DialougeOptionsAnim * 255) + "#c031027027" + OptionStrings[i], Spr_Font_MilleniumFont, 0.4, 0);
            }
        }           
    }    
    
    /***************************************************************************
    // CombatUIState.FleeMenu
    ***************************************************************************/
    if(MenuAnim[CombatUIState.FleeMenu] &gt; 0)
    {
        var FleeAnimUpperOffset = (1 -Scr_SCurve(MenuAnim[CombatUIState.FleeMenu])) * 200;
        var FleeAnimLowerOffset = (1 -Scr_SCurve(MenuAnim[CombatUIState.FleeMenu])) * 180;
        
        // HEADER
        draw_sprite_ext( GUI_Combat_Flee_Header, -1, 210, 139 - FleeAnimUpperOffset, 1.0, 1.0, 0, c_white, 1.0);
        
        // PANEL
        draw_sprite_ext( GUI_Combat_Flee_Panel, -1, 320, 210 + FleeAnimLowerOffset, 1.0, 1.0, 0, c_white, 1.0);
        
        // BUTTONS
        draw_sprite_ext( GUI_Combat_Flee_YesButton, -1, 240 + (FleeButtonDisplacement[0] * 16), 209 + FleeAnimLowerOffset, 1.0, 1.0, 0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Flee_NoButton, -1, 401 + (FleeButtonDisplacement[1] * 16), 209 + FleeAnimLowerOffset, 1.0, 1.0, 0, c_white, 1.0);
        
        // CHANGE AMMO ARROW
        var s = sin(ArrowPulseTimer / 6);
        draw_sprite_ext( GUI_Combat_Command_Arrow, 1, 176 - (s * 8) + (Scr_SCurve(FleeArrowAnim) * 161), 209 + FleeAnimLowerOffset, lerp(1.4, 1.0, clamp(s, 0.0, 1.0)), lerp(1.2, 1.0, clamp(-s, -1.0, 0.0)), 0, c_white, 1.0);  
        
        // ??
        draw_sprite_ext( GUI_Combat_Flee_QuestionMarks, -1, 382, 160 - FleeAnimUpperOffset, 0.8 + j, 0.8 + j, HeaderOverlayRotation, c_white, 1.0);
    }
    
    /***************************************************************************
    // OPEN AND CLOSE ANIMS
    ***************************************************************************/
    if(MenuAnim[CombatUIState.OPEN_PlayerTurn] &gt; 0)
    {
        var PlayerAnimOffset = -100 + 420 * SlideInAnim + 420 * SlideOutAnim;
        var TurnAnimOffset = 740 - 420 * SlideInAnim - 420 * SlideOutAnim;
        var SpeedLinesScale = SlideInAnim - SlideOutAnim;
        
        // SPEED LINES
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing_CENTERED, -1, 0 - SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing_CENTERED, -1, 512 - SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing_CENTERED, -1, 1024 - SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_CENTERED, -1, -512 + SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_CENTERED, -1, 0 + SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_CENTERED, -1, 512 + SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        
        // TEXT
        draw_sprite_ext(GUI_Combat_OpenCloseAnim_Player, 0, PlayerAnimOffset, 180, 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext(GUI_Combat_OpenCloseAnim_Turn, 0, TurnAnimOffset, 180, 1.0, 1.0, 0.0, c_white, 1.0);
    }
    if(MenuAnim[CombatUIState.CLOSE_EnemyTurn] &gt; 0)
    {
        var TurnAnimOffset = -100 + 420 * SlideInAnim + 420 * SlideOutAnim;
        var PlayerAnimOffset = 740 - 420 * SlideInAnim - 420 * SlideOutAnim;
        var SpeedLinesScale = SlideInAnim - SlideOutAnim;
        
        // SPEED LINES
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing_CENTERED, -1, 0 - SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing_CENTERED, -1, 512 - SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_Backing_CENTERED, -1, 1024 - SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_CENTERED, -1, -512 + SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_CENTERED, -1, 0 + SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        draw_sprite_ext( GUI_Combat_Misc_SpeedLines_Horizontal_CENTERED, -1, 512 + SpeedLinesOffset, 180, 1.0, SpeedLinesScale, 0.0, c_white, 1.0);
        
        // TEXT
        draw_sprite_ext(GUI_Combat_OpenCloseAnim_Enemy, 0, PlayerAnimOffset, 180, 1.0, 1.0, 0.0, c_white, 1.0);
        draw_sprite_ext(GUI_Combat_OpenCloseAnim_Turn, 0, TurnAnimOffset, 180, 1.0, 1.0, 0.0, c_white, 1.0);
    }
    /***************************************************************************
    // RESULT SCREEN
    ***************************************************************************/
    if(MenuAnim[CombatUIState.ResultsScreen] &gt; 0)
    {
        var ResultHeaderAnimOffset = (1 -Scr_SCurve(MenuAnim[CombatUIState.ResultsScreen])) * 80;
        var ResultsStuffAnimOffset = (1 -Scr_SCurve(MenuAnim[CombatUIState.ResultsScreen])) *  240;
        var HeadingPopinAnim = sin(lerp(0, 0.6 * pi, MenuAnim[CombatUIState.ResultsScreen]));
        
        var StatAnimInfoOffset = (1 - Scr_SCurve(StatBoostMessageAnim)) * 460;
        
        // HEADING
        draw_sprite_ext(GUI_Combat_Results_Heading, 0,  143, 16 - ResultHeaderAnimOffset, 1.0, 1.0, 0.0, c_white, 1.0);
        
        // SUBHEADING
        draw_sprite_ext(GUI_Combat_Results_SubHeading, 0,  475, 72, HeadingPopinAnim, HeadingPopinAnim, 0.0, c_white, 1.0);
        
        // EXP 
        draw_sprite_ext(GUI_Combat_Results_Exp, 0,  300 + ResultsStuffAnimOffset, 105, 1.0, 1.0, 0.0, c_white, 1.0);
        Scr_DrawText(Scr_FormatNumString(Obj_PlayerData.Experience, 3) + "/" + Scr_FormatNumString(Scr_CalcExpToNextLevel(), 3), 376 + ResultsStuffAnimOffset, 106, 0.65, GUI_Font_OldStyleKana_Lrg);
        
        // GOLD
        draw_sprite_ext(GUI_Combat_Results_Gold, 0, 300 + ResultsStuffAnimOffset, 154, 1.0, 1.0, 0.0, c_white, 1.0);
        Scr_DrawText(Scr_FormatNumString(Obj_PlayerData.Gold, 6), 376 + ResultsStuffAnimOffset, 155, 0.65, GUI_Font_OldStyleKana_Lrg);
        
        // STATS PANEL
        draw_sprite_ext(GUI_Combat_Results_StatsBacking, 0, 459 + ResultsStuffAnimOffset, 201, 1.0, 1.0, 0.0, c_white, 1.0);
        
            // Player Level
            Scr_DrawText(Scr_FormatNumString(Obj_PlayerData.Level, 2), 507 + ResultsStuffAnimOffset, 205, 1, GUI_Font_OldStyleKana);
            
            // HP
            draw_sprite_ext(GUI_Combat_PlayerStats_HealthFill, 0,  507 + ResultsStuffAnimOffset, 227, clamp(Obj_PlayerData.Hitpoints/Obj_PlayerData.MaxHitpoints, 0.0, 1.0), 1.0, 0.0, c_white, 1.0);
            Scr_DrawText(string(Obj_PlayerData.Hitpoints) + "/" + string(Obj_PlayerData.MaxHitpoints), 512 + ResultsStuffAnimOffset, 225, 0.8, GUI_Font_OldStyleKana); 
            
            // MP
            draw_sprite_ext(GUI_Combat_PlayerStats_ManaFill, 0,  507 + ResultsStuffAnimOffset, 247, clamp(Obj_PlayerData.Hitpoints/Obj_PlayerData.MaxHitpoints, 0.0, 1.0), 1.0, 0.0, c_white, 1.0);
            Scr_DrawText(string(Obj_PlayerData.Manapoints) + "/" + string(Obj_PlayerData.MaxManapoints), 512 + ResultsStuffAnimOffset, 245, 0.8, GUI_Font_OldStyleKana); 
            
            // Strength Stat
            Scr_DrawText(Scr_FormatNumString(Obj_PlayerData.Strength, 2), 524 + ResultsStuffAnimOffset, 265, 1, GUI_Font_OldStyleKana);
            
            // Endurance Stat
            Scr_DrawText(Scr_FormatNumString(Obj_PlayerData.Endurance, 2), 524 + ResultsStuffAnimOffset, 285, 1, GUI_Font_OldStyleKana);
            
            // Agility Stat
            Scr_DrawText(Scr_FormatNumString(Obj_PlayerData.Agility, 2), 524 + ResultsStuffAnimOffset, 305, 1, GUI_Font_OldStyleKana);
            
            // Luck Stat
            Scr_DrawText(Scr_FormatNumString(Obj_PlayerData.Luck, 2), 524 + ResultsStuffAnimOffset, 325, 1, GUI_Font_OldStyleKana);
            
        // LEVEL UP
        if(LevelUpAnimTimer &gt; 0)
        {
            var LvLUpA = sin(lerp(0, 0.6 * pi, clamp(0, 1, (LevelUpAnimTimerMax - LevelUpAnimTimer) / (LevelUpAnimTimerMax / 8))));
            var LvLUpB = 1 - sin(lerp(0, 0.6 * pi, clamp(0, 1, LevelUpAnimTimer / (LevelUpAnimTimerMax / 8))));
            draw_sprite_ext(GUI_Combat_Results_LevelUp, 0,  448, 262, LvLUpA - LvLUpB, LvLUpA - LvLUpB, 0.0, c_white, 1.0);
        }
        
        // STAT BOOST DESC
        if(StatBoostMessageAnim &gt; 0)
        {
            draw_sprite_ext( GUI_Combat_Ammo_AmmoDesc, -1, 0 - StatAnimInfoOffset, 316, 1, 1, 0, c_white, 1.0);
            Scr_DrawText("#c031027027" + "Distribute stat points. " + string(StatBoostsRemaining) + " remaining.", 5 - StatAnimInfoOffset, 328, 0.8, GUI_Font_OldStyleKana);
            
            // STAT BOOST ARROW
            draw_sprite_ext( GUI_Combat_Results_StatUpArrow, -1, 473, 267 + (yPosition * 20), 1, 1, 0, c_white, 1.0);
        }
     }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
